# Rust 数据类型深度解析

## 一、设计哲学

### 1.1 零成本抽象

Rust 的抽象不会带来运行时开销，编译期完成类型检查和优化。

### 1.2 所有权系统

每个值有且仅有一个所有者，离开作用域时自动释放。

```rust
let s1 = String::from("hello");
let s2 = s1;        // s1 的所有权转移给 s2
// println!("{}", s1);  // 错误！s1 已无效
println!("{}", s2);  // OK
```

### 1.3 显式优于隐式

类型必须明确，无隐式类型转换。

```rust
let x: i32 = 42;
let y: i64 = x as i64;  // 必须显式转换
```

---

## 二、标量类型

### 2.1 整数

| 类型 | 大小 | 范围 |
|------|------|------|
| `i8` / `u8` | 1 字节 | -128~127 / 0~255 |
| `i16` / `u16` | 2 字节 | ±32,767 / 0~65,535 |
| `i32` / `u32` | 4 字节 | ±21亿 / 0~42亿 |
| `i64` / `u64` | 8 字节 | ±9×10¹⁸ |
| `i128` / `u128` | 16 字节 | 极大范围 |
| `isize` / `usize` | 平台相关 | 指针大小 |

```rust
let a: i32 = 42;
let b: u8 = 255;
let c = 1_000_000i64;  // 下划线分隔，后缀指定类型
let d = 0xff;          // 十六进制
let e = 0o77;          // 八进制
let f = 0b1111;        // 二进制
```

**内存布局**（以 i32 为例，固定 4 字节）：

```
i32 值 = 42 (0x0000002A)

┌────┬────┬────┬────┐
│ 2A │ 00 │ 00 │ 00 │  小端序 (little-endian)
└────┴────┴────┴────┘
  低地址 ────→ 高地址

有符号整数使用补码表示：
- 正数: 直接二进制
- 负数: 取反加一
- i32 范围: -2³¹ ~ 2³¹-1
```

**与 Python 对比**：
- Rust 整数**固定大小**，Python 整数**任意精度**
- Rust 会**溢出**（debug 模式 panic），Python 不会

### 2.2 浮点数

| 类型 | 大小 | 精度 |
|------|------|------|
| `f32` | 4 字节 | 单精度 |
| `f64` | 8 字节 | 双精度（默认） |

```rust
let x = 2.0;      // f64（默认）
let y: f32 = 3.0; // f32
```

**内存布局**（IEEE 754 标准）：

```
f32 (32位):
┌───┬──────────┬───────────────────────┐
│ S │ Exponent │       Mantissa        │
│1位│   8 位   │        23 位          │
└───┴──────────┴───────────────────────┘

f64 (64位):
┌───┬─────────────┬────────────────────────────────────────────────────┐
│ S │  Exponent   │                    Mantissa                        │
│1位│   11 位     │                     52 位                          │
└───┴─────────────┴────────────────────────────────────────────────────┘

S = 符号位 (0正 1负)
精度: f32 约 7 位有效数字，f64 约 15-17 位
```

### 2.3 布尔值

```rust
let t: bool = true;
let f: bool = false;
// 占用 1 字节，不能与整数互转
```

**内存布局**（1 字节）：

```
┌────────┐
│ 0 或 1 │  只占 1 字节
└────────┘

- false = 0x00
- true  = 0x01
- 不能与整数隐式转换（需要显式判断）
```

**与 Python 对比**：Rust 的 `bool` 不是整数子类，不能做算术运算。

### 2.4 字符

```rust
let c: char = 'z';
let emoji: char = '😀';
// 4 字节，表示 Unicode 标量值
```

**内存布局**（固定 4 字节）：

```
char 'A' (U+0041):
┌────┬────┬────┬────┐
│ 41 │ 00 │ 00 │ 00 │
└────┴────┴────┴────┘

char '中' (U+4E2D):
┌────┬────┬────┬────┐
│ 2D │ 4E │ 00 │ 00 │
└────┴────┴────┴────┘

char '😀' (U+1F600):
┌────┬────┬────┬────┐
│ 00 │ F6 │ 01 │ 00 │
└────┴────┴────┴────┘

- 范围: U+0000 ~ U+10FFFF（排除代理对）
- 与 String 的 UTF-8 编码不同！
```

**与 Python 对比**：Rust `char` 是单独类型，Python 没有字符类型（单字符就是长度为1的字符串）。

---

## 三、复合类型

### 3.1 元组 Tuple

固定长度，可包含不同类型。

```rust
let tup: (i32, f64, char) = (500, 6.4, 'y');

// 解构
let (x, y, z) = tup;

// 索引访问
let first = tup.0;
let second = tup.1;
```

**内存布局**（连续存储，可能有填充）：

```
(i32, f64, char) = (500, 6.4, 'y')

栈上（按对齐要求排列）:
┌─────────────┬─────────────┬────────────────────────┬─────────────┐
│  i32 (4B)   │ padding(4B) │       f64 (8B)         │  char (4B)  │
│    500      │    ----     │        6.4             │    'y'      │
└─────────────┴─────────────┴────────────────────────┴─────────────┘
偏移: 0          4              8                       16

总大小: 24 字节 (因为 f64 需要 8 字节对齐)
```

### 3.2 数组 Array

固定长度，相同类型，栈上分配。

```rust
let arr: [i32; 5] = [1, 2, 3, 4, 5];
let zeros = [0; 5];  // [0, 0, 0, 0, 0]

let first = arr[0];
let len = arr.len();

// 越界访问会 panic
// let x = arr[10];  // 运行时 panic
```

**内存布局**（栈上连续）：

```
[i32; 5] = [1, 2, 3, 4, 5]

栈上 (20 字节):
┌────────┬────────┬────────┬────────┬────────┐
│   1    │   2    │   3    │   4    │   5    │
│  (4B)  │  (4B)  │  (4B)  │  (4B)  │  (4B)  │
└────────┴────────┴────────┴────────┴────────┘
 arr[0]   arr[1]   arr[2]   arr[3]   arr[4]

- 完全在栈上，无堆分配
- 长度是类型的一部分：[i32; 5] ≠ [i32; 3]
- 大小 = 元素大小 × 长度
```

**与 Python 对比**：
- Rust 数组**固定长度**，Python 列表**动态长度**
- Rust 数组元素**同类型**，Python 列表可**异构**

---

## 四、所有权类型

### 4.1 String

堆上分配，可变，拥有所有权。

```rust
let mut s = String::from("hello");
s.push_str(", world!");
println!("{}", s);  // "hello, world!"

// 所有权转移
let s2 = s;
// println!("{}", s);  // 错误！
```

**内存布局**（24 字节 = 3 个指针大小）：

```
String::from("hello")

     栈上 (24 字节)                    堆上
┌─────────────────────┐         ┌───┬───┬───┬───┬───┬───┬───┬───┐
│ ptr      (8 字节)   │────────→│ h │ e │ l │ l │ o │   │   │   │
├─────────────────────┤         └───┴───┴───┴───┴───┴───┴───┴───┘
│ len: 5   (8 字节)   │          ←── 已使用 ──→ ←── 预留 ──→
├─────────────────────┤
│ cap: 8   (8 字节)   │         UTF-8 编码，每字符 1-4 字节
└─────────────────────┘

- ptr: 指向堆上数据
- len: 当前字节数（不是字符数！）
- cap: 已分配容量
```

### 4.2 &str（字符串切片）

不可变引用，不拥有数据。

```rust
let s: String = String::from("hello");
let slice: &str = &s[0..3];  // "hel"

let literal: &str = "hello";  // 字符串字面量是 &'static str
```

**内存布局**（胖指针，16 字节）：

```
&str 切片 (指向 "hel")

    栈上 (16 字节)                    堆上 (String 的数据)
┌─────────────────────┐         ┌───┬───┬───┬───┬───┐
│ ptr      (8 字节)   │────────→│ h │ e │ l │ l │ o │
├─────────────────────┤         └───┴───┴───┘
│ len: 3   (8 字节)   │              ↑
└─────────────────────┘          只借用前3字节

字符串字面量 "hello":
┌─────────────────────┐         ┌───────────────────┐
│ ptr      (8 字节)   │────────→│ 静态存储区 "hello" │
├─────────────────────┤         └───────────────────┘
│ len: 5   (8 字节)   │         (程序二进制中，生命周期 'static)
└─────────────────────┘

- 胖指针 = 指针 + 长度
- 不拥有数据，只是借用
```

**与 Python 对比**：
- Python `str` 不可变，在堆上
- Rust `String` 可变，`&str` 不可变

### 4.3 Vec（向量）

动态数组，堆上分配。

```rust
let mut v: Vec<i32> = Vec::new();
v.push(1);
v.push(2);
v.push(3);

// 宏创建
let v2 = vec![1, 2, 3];

// 访问
let third = &v[2];      // 可能 panic
let third = v.get(2);   // 返回 Option<&T>
```

**内存布局**（与 String 类似，24 字节）：

```
Vec<i32> = vec![1, 2, 3]

     栈上 (24 字节)                        堆上
┌─────────────────────┐         ┌────┬────┬────┬────┬────┐
│ ptr      (8 字节)   │────────→│  1 │  2 │  3 │    │    │
├─────────────────────┤         └────┴────┴────┴────┴────┘
│ len: 3   (8 字节)   │         4B   4B   4B   预留空间
├─────────────────────┤
│ cap: 5   (8 字节)   │
└─────────────────────┘

扩容策略：容量不足时翻倍
- 元素直接存储（不是指针）
- 所有元素类型相同
```

**与 Python 对比**：类似 Python 的 `list`，但元素类型必须相同。

### 4.4 HashMap

```rust
use std::collections::HashMap;

let mut scores: HashMap<String, i32> = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Red"), 50);

// 访问
let score = scores.get("Blue");  // Option<&i32>
```

**内存布局**（哈希表 + 桶数组）：

```
HashMap<String, i32>

     栈上                              堆上
┌─────────────────────┐         ┌──────────────────────────────────┐
│ 桶数组指针          │────────→│ bucket │ bucket │ bucket │ ...   │
├─────────────────────┤         └────┬───┴────┬───┴────────┴───────┘
│ 桶数量              │              │        │
├─────────────────────┤              ↓        ↓
│ 元素数量            │         ┌────────┐ ┌────────┐
├─────────────────────┤         │ hash   │ │ hash   │
│ ...                 │         │ key    │ │ key    │
└─────────────────────┘         │ value  │ │ value  │
                                └────────┘ └────────┘

- 使用 SipHash 算法（防 DoS）
- 开放寻址法解决冲突
- 负载因子控制扩容
```

---

## 五、引用与借用

### 5.1 不可变引用 &T

```rust
let s = String::from("hello");
let r1 = &s;  // 不可变借用
let r2 = &s;  // 可以有多个
println!("{}, {}", r1, r2);
```

**内存布局**（普通引用 8 字节，切片引用 16 字节）：

```
普通引用 &T (8 字节):        切片引用 &[T] / &str (16 字节):
┌─────────────┐             ┌─────────────┐
│  ptr (8B)   │             │  ptr (8B)   │
└──────┬──────┘             ├─────────────┤
       │                    │  len (8B)   │
       ↓                    └──────┬──────┘
    目标数据                        │
                                   ↓
                              连续数据
```

### 5.2 可变引用 &mut T

```rust
let mut s = String::from("hello");
let r = &mut s;  // 可变借用
r.push_str("!");
// 同一时间只能有一个可变引用
```

**内存布局**（与 &T 相同，区别在于编译期权限）：

```
&T 和 &mut T 大小相同，区别：
┌─────────────────────────────────────────┐
│  &T     │ 只读访问 │ 可多个同时存在      │
├─────────┼──────────┼───────────────────── │
│ &mut T  │ 读写访问 │ 独占，同时只能有一个│
└─────────────────────────────────────────┘
```

### 5.3 借用规则

1. **任意时刻**，只能有：多个不可变引用 **或** 一个可变引用
2. 引用必须始终有效

```rust
let mut s = String::from("hello");

let r1 = &s;
let r2 = &s;
// let r3 = &mut s;  // 错误！不能同时有不可变和可变引用

println!("{}, {}", r1, r2);
// r1, r2 不再使用后，可以创建可变引用
let r3 = &mut s;  // OK
```

---

## 六、底层原理

### 6.1 内存布局

```rust
use std::mem;

println!("i32: {} 字节", mem::size_of::<i32>());     // 4
println!("i64: {} 字节", mem::size_of::<i64>());     // 8
println!("char: {} 字节", mem::size_of::<char>());   // 4
println!("bool: {} 字节", mem::size_of::<bool>());   // 1
println!("&str: {} 字节", mem::size_of::<&str>());   // 16 (ptr + len)
println!("String: {} 字节", mem::size_of::<String>()); // 24 (ptr + len + cap)
```

### 6.2 栈 vs 堆

| 类型 | 存储位置 | 特点 |
|------|----------|------|
| 标量、数组、元组 | 栈 | 固定大小，快速分配 |
| String, Vec, HashMap | 堆 | 动态大小，需要管理 |

### 6.3 Copy 与 Clone

```rust
// Copy：栈上按位复制（标量类型自动实现）
let x = 5;
let y = x;  // 复制，x 仍有效

// Clone：显式深拷贝
let s1 = String::from("hello");
let s2 = s1.clone();  // 深拷贝
println!("{}, {}", s1, s2);  // 都有效
```

---

## 附录：类型速查

### 常用类型

| 类型 | 说明 | 示例 |
|------|------|------|
| `i32`, `u32` | 整数 | `42`, `0xff` |
| `f64` | 浮点数 | `3.14` |
| `bool` | 布尔 | `true`, `false` |
| `char` | 字符 | `'a'`, `'中'` |
| `&str` | 字符串切片 | `"hello"` |
| `String` | 字符串 | `String::from("hi")` |
| `[T; N]` | 数组 | `[1, 2, 3]` |
| `Vec<T>` | 向量 | `vec![1, 2, 3]` |
| `(T1, T2)` | 元组 | `(1, "hi")` |
| `HashMap<K,V>` | 哈希表 | `HashMap::new()` |

### 类型转换

```rust
// 数值转换
let x: i32 = 42;
let y: i64 = x as i64;
let z: f64 = x as f64;

// 字符串转换
let s: String = 42.to_string();
let n: i32 = "42".parse().unwrap();

// String <-> &str
let s: String = String::from("hello");
let slice: &str = &s;
let owned: String = slice.to_string();
```

---

## 练习

完成 `exercises/` 目录下的习题，答案在 `solutions/`。
